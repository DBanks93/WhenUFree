from calendar import calendar
from typing import Dict, List, Optional
from datetime import datetime, timedelta


def remove_working_times(people: Dict[str, Dict[str, List[str]]],
                         calendar: Dict[str, Dict[str, List[str]]],
                         slot_duration: int) -> Dict[str, Dict[str, List[str]]]:
    """
    Modify the `people` dictionary by removing the times they are working according to the calendar,
    accounting for the slot duration (in minutes).

    :param people: The original people availability dictionary (modified in place).
    :param calendar: The final calendar generated by the TimetableGenerator class.
    :param slot_duration: Duration of each slot in minutes (e.g., 120 for a 2-hour slot).
    """
    slot_step = slot_duration // 60  # Convert slot duration to hours

    # Iterate through each day and time slot in the calendar
    for day, slots in calendar.items():
        for time_slot, assigned_people in slots.items():
            for person in assigned_people:
                if person in people and day in people[person]:
                    # Remove the range of times for the current slot duration
                    current_time = datetime.strptime(time_slot, '%H:%M')
                    for _ in range(slot_step):
                        time_str = current_time.strftime('%H:%M')
                        if time_str in people[person][day]:
                            people[person][day].remove(time_str)
                        current_time += timedelta(hours=1)

    return people

class TimetableGenerator:
    max_pps: int
    min_pps: int
    slot_duration: int  # In minutes
    people: Dict[str, Dict[str, List[str]]]  # People availability (day of the week to time slots)
    calendar: Dict[str, Dict[str, List[str]]]  # Calendar (day of the week to time slots)

    def __init__(self, people: Dict[str, Dict[str, List[str]]],
                 days_of_week: List[str],
                 start_time: str,
                 end_time: str,
                 slot_duration: int,
                 max_pps: int = 1, min_pps: int = 0) -> None:
        self.max_pps = max_pps
        self.min_pps = min_pps
        self.slot_duration = slot_duration
        self.people = people

        # Parse start and end times for each day
        self.start_time = datetime.strptime(start_time, '%H:%M')
        self.end_time = datetime.strptime(end_time, '%H:%M')

        # Create the empty calendar based on the days of the week and time slots
        self.calendar = self.generate_empty_calendar(days_of_week)

    def generate_empty_calendar(self, days_of_week: List[str]) -> Dict[str, Dict[str, List[str]]]:
        """
        Generates an empty calendar with time slots between start_time and end_time for each day in the week.
        """
        calendar = {}

        for day in days_of_week:
            calendar[day] = {}

            # Generate time slots for the day
            current_time = self.start_time
            while current_time + timedelta(minutes=self.slot_duration) <= self.end_time:
                slot_str = current_time.strftime('%H:%M')
                calendar[day][slot_str] = []
                current_time += timedelta(minutes=self.slot_duration)

        return calendar

    def is_available_for_slot(self, name: str, day: str, slot_time: str) -> bool:
        """
        Checks if a person is available for the entire duration of the time slot on the given day of the week.
        """
        if day not in self.people[name]:
            return False

        available_times = self.people[name][day]

        # Check if the person is available for the entire slot duration
        current_time = datetime.strptime(slot_time, '%H:%M')
        for _ in range(self.slot_duration // 60):  # Check each hour in the slot
            time_str = current_time.strftime('%H:%M')
            if time_str not in available_times:
                return False
            current_time += timedelta(minutes=60)

        return True

    def find_least_filled_slot(self, day: str, available_slots: List[str]) -> Optional[str]:
        """
        Find the least filled time slot on the specified day of the week.
        """
        least_filled_slot = None
        min_people = float('inf')

        for slot in available_slots:
            people_in_slot = len(self.calendar[day][slot])
            if people_in_slot < self.max_pps and people_in_slot < min_people:
                min_people = people_in_slot
                least_filled_slot = slot

        return least_filled_slot

    def add_person_to_calendar(self, name: str, day: str) -> Optional[str]:
        """
        Add a person to the least filled slot on a specific day of the week.
        """
        available_slots = [slot for slot in self.calendar[day] if self.is_available_for_slot(name, day, slot)]
        slot = self.find_least_filled_slot(day, available_slots)
        if slot is not None:
            self.calendar[day][slot].append(name)
            return slot
        return None

    def add_people_to_calendar(self):
        """
        Assigns people to the time slots over the week based on their availability and slot capacity.
        """
        for name, availability in self.people.items():
            for day, available_times in availability.items():
                if day in self.calendar:
                    self.add_person_to_calendar(name, day)

    def ensure_minimum_people(self) -> None:
        """
        Ensure each slot meets the minimum number of people requirement by reassigning people if needed.
        """
        for day, slots in self.calendar.items():
            for slot, people in slots.items():
                if len(people) < self.min_pps:
                    for name in self.people:
                        if self.is_available_for_slot(name, day, slot):
                            self.calendar[day][slot].append(name)
                            break

    def best_fill_calendar(self) -> None:
        """
        Main function to fill the calendar and ensure all slots are filled optimally.
        """
        self.add_people_to_calendar()
        self.ensure_minimum_people()

        if not self.all_slots_filled():
            print("Some slots are not filled optimally.")

    def all_slots_filled(self) -> bool:
        """
        Check if all slots meet the minimum number of people requirement.
        """
        for day, slots in self.calendar.items():
            for slot in slots:
                if len(self.calendar[day][slot]) < self.min_pps:
                    return False
        return True

    def print_calendar(self) -> None:
        """
        Prints the calendar in a readable format.
        """
        for day, slots in self.calendar.items():
            print(f"Day: {day}")
            for slot, people in slots.items():
                print(f"  Time Slot: {slot} - People: {', '.join(people)}")

    def generate_timetable(self) -> Dict[str, Dict[str, List[str]]]:
        self.best_fill_calendar()
        return self.calendar

